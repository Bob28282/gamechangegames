<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>mGBA Player (iframe)</title>
  <style>
    body{margin:0;background:#071021;color:#e6eef6;font-family:Inter,system-ui, -apple-system, "Segoe UI", Roboto;}
    #wrap{padding:12px}
    #status{color:#9aa4b2;margin-bottom:8px}
    #canvas{width:480px;height:320px;background:#000;display:block;border-radius:6px;image-rendering:pixelated}
    .warning{color:#ffb3b3}
  </style>
</head>
<body>
  <div id="wrap">
    <div id="status">mGBA iframe: waiting for ROM. Place your mGBA web build (mgba.js, mgba.wasm) in /mgba/</div>

    <!-- A canvas target for the mGBA build to render into (if your build exposes a way to swap the framebuffer target) -->
    <canvas id="canvas" width="240" height="160"></canvas>

    <div style="margin-top:8px">
      <small class="warning">This file is a helper/template. You must add the official mGBA web build files (mgba.js, mgba.wasm) into this folder for full functionality. See README for guidance.</small>
    </div>

    <div style="margin-top:12px">
      <label style="display:inline-block;background:#0b1220;padding:6px 8px;border-radius:6px;cursor:pointer">
        Or open a local ROM here
        <input id="local-file" type="file" accept=".gba" style="display:none"/>
      </label>
    </div>
  </div>

  <!-- This file expects mgba.js to be present at the same directory (i.e., /mgba/mgba.js). -->
  <script>
    const statusEl = document.getElementById('status');
    const canvas = document.getElementById('canvas');
    const localFile = document.getElementById('local-file');

    function setStatus(t) {
      statusEl.textContent = 'mGBA iframe: ' + t;
    }

    // Load mgba.js if present (non-blocking)
    (function loadMgbaScript() {
      const script = document.createElement('script');
      script.src = './mgba.js';
      script.async = true;
      script.onload = () => {
        setStatus('mgba.js loaded. Waiting for ROM or user input.');
      };
      script.onerror = () => {
        setStatus('mgba.js not found at /mgba/mgba.js. Place mGBA web build files in the mgba/ directory.');
      };
      document.head.appendChild(script);
    })();

    // Utility to write file to Emscripten FS (if available)
    function writeRomToFS(filename, uint8array) {
      if (typeof Module === 'undefined' || !Module.FS_createDataFile) {
        throw new Error('Emscripten Module.FS_createDataFile is not available. Adapt mgba/player.html to your mGBA build.');
      }
      const path = '/roms';
      try { Module.FS.mkdir(path); } catch (e) { /* ignore exists */ }
      const full = path + '/' + filename;
      try { Module.FS.unlink(full); } catch (e) { /* ignore */ }
      Module.FS_createDataFile(path, filename, uint8array, true, true);
      return full;
    }

    // New: attempt to find a GbaContext (common in some web builds) and call its play function.
    // This function tries multiple strategies:
    // 1) If a GbaContext object exists (window.GbaContext or Module.GbaContext) and exposes a play/load method, call it.
    // 2) If not, fall back to Module.ccall / Module._run_from_path as before.
    // 3) If none available, instruct the user to use the UI or adapt this file.
    async function callMgbaRunFunction(romPath, romUint8) {
      setStatus('Attempting to start via GbaContext or Module...');
      // Wait a short time for Module/GbaContext to initialize if it's in-flight
      await new Promise(resolve => setTimeout(resolve, 80));

      // Collection of candidate contexts to test
      const candidates = [];

      if (typeof window !== 'undefined') {
        if (window.GbaContext) candidates.push({ ctx: window.GbaContext, where: 'window.GbaContext' });
        if (window.mgba && window.mgba.GbaContext) candidates.push({ ctx: window.mgba.GbaContext, where: 'window.mgba.GbaContext' });
      }
      if (typeof Module !== 'undefined') {
        if (Module.GbaContext) candidates.push({ ctx: Module.GbaContext, where: 'Module.GbaContext' });
        if (Module.mgba && Module.mgba.GbaContext) candidates.push({ ctx: Module.mgba.GbaContext, where: 'Module.mgba.GbaContext' });
      }

      // Also include the Module itself as a candidate where APIs might be attached
      if (typeof Module !== 'undefined') candidates.push({ ctx: Module, where: 'Module' });

      // Helper to attempt calling a context
      function tryCallContext(obj, name) {
        try {
          // If the context is a constructor/instance, normalize
          const ctx = (typeof obj === 'function' && obj.prototype) ? obj : obj;
          // Common APIs: play, playROM, loadROM, loadRom, run, start
          const methods = ['play', 'playROM', 'playRom', 'loadROM', 'loadRom', 'run', 'start'];
          for (const m of methods) {
            const fn = ctx[m];
            if (typeof fn === 'function') {
              setStatus(`Calling ${name}.${m}(...)`);
              // Try to call with romPath first, then with Uint8Array
              try {
                // prefer passing the actual bytes if function accepts ArrayBuffer/Uint8Array
                if (fn.length >= 1) {
                  // Some APIs expect a path (string), some expect bytes; try bytes first when available
                  if (romUint8 && (m.toLowerCase().includes('rom') || m.toLowerCase().includes('play'))) {
                    const maybe = fn.call(ctx, romUint8);
                    parent.postMessage({ type: 'status', text: `mGBA: invoked ${name}.${m} with bytes` }, '*');
                    return true;
                  }
                  // Fallback to path string
                  fn.call(ctx, romPath);
                  parent.postMessage({ type: 'status', text: `mGBA: invoked ${name}.${m} with path ${romPath}` }, '*');
                  return true;
                } else {
                  // no-arg function (unlikely) just call it
                  fn.call(ctx);
                  parent.postMessage({ type: 'status', text: `mGBA: invoked ${name}.${m}` }, '*');
                  return true;
                }
              } catch (err) {
                console.warn(`Call to ${name}.${m} failed:`, err);
                // continue trying other methods
              }
            }
          }
        } catch (e) {
          console.warn('Error while probing context', name, e);
        }
        return false;
      }

      // Try candidates
      for (const c of candidates) {
        if (!c.ctx) continue;
        if (tryCallContext(c.ctx, c.where)) {
          setStatus(`Started using ${c.where}`);
          return;
        }
      }

      // If we reach here, try Emscripten ccall or raw symbol as fallback
      if (typeof Module !== 'undefined' && typeof Module.ccall === 'function') {
        try {
          setStatus('Trying Module.ccall fallback (run_from_path/run_from_memory)');
          // try run_from_path with the string path
          try {
            Module.ccall('run_from_path', 'number', ['string'], [romPath]);
            parent.postMessage({ type: 'status', text: 'mGBA: Module.ccall run_from_path invoked' }, '*');
            return;
          } catch (e) { /* ignore */ }
          // try a memory-based variant if the build expects pointer/size — we cannot reliably do that here
        } catch (e) {
          console.warn('Module.ccall fallback failed', e);
        }
      }

      if (typeof Module !== 'undefined' && typeof Module._run_from_path === 'function') {
        try {
          setStatus('Trying Module._run_from_path fallback');
          Module._run_from_path(romPath);
          parent.postMessage({ type: 'status', text: 'mGBA: Module._run_from_path invoked' }, '*');
          return;
        } catch (e) {
          console.warn('Module._run_from_path fallback failed', e);
        }
      }

      // Last-ditch: if bytes available, and Module provides a simple API to load bytes (e.g., Module.loadROMBytes)
      const byteLoadCandidates = ['loadROMBytes', 'loadBytes', 'load_rom_bytes', 'load_rom'];
      if (romUint8 && typeof Module !== 'undefined') {
        for (const name of byteLoadCandidates) {
          const fn = Module[name];
          if (typeof fn === 'function') {
            try {
              setStatus(`Calling Module.${name} with ROM bytes`);
              fn(romUint8);
              parent.postMessage({ type: 'status', text: `mGBA: Module.${name} invoked` }, '*');
              return;
            } catch (e) {
              console.warn(`Module.${name} failed`, e);
            }
          }
        }
      }

      // Nothing worked
      setStatus('Could not auto-start mGBA: adapt player.html to your build or use the mGBA UI to load /roms/' + (romPath.split('/').pop() || 'ROM'));
      parent.postMessage({ type: 'error', text: 'Could not auto-start mGBA; adapt player.html to your build.' }, '*');
    }

    // PostMessage handler: receive ROM from parent
    window.addEventListener('message', async (evt) => {
      const data = evt.data || {};
      if (!data || data.type !== 'load-rom') return;
      setStatus('Received ROM: ' + data.filename + ' — attempting to load...');
      try {
        let buffer = data.buffer;
        let uint8;
        if (buffer instanceof ArrayBuffer) {
          uint8 = new Uint8Array(buffer);
        } else if (ArrayBuffer.isView(buffer)) {
          // e.g., Uint8Array
          uint8 = new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);
        } else {
          setStatus('Received ROM buffer in unexpected format.');
          return;
        }

        // Wait for Module runtime if present
        if (typeof Module !== 'undefined' && Module['calledRun'] === false) {
          await new Promise((resolve) => {
            if (Module['onRuntimeInitialized']) {
              const prev = Module['onRuntimeInitialized'];
              Module['onRuntimeInitialized'] = function() {
                try { prev(); } catch(e) {}
                resolve();
              };
            } else {
              setTimeout(resolve, 500);
            }
          });
        }

        // write into FS if available and remember path
        let romPath = '/roms/' + data.filename;
        try {
          writeRomToFS(data.filename, uint8);
          setStatus('ROM written to FS at ' + romPath + ' — trying to start emulator...');
        } catch (err) {
          // writing to FS failed (Module.FS not available). We'll still try direct-context call with bytes.
          console.warn('writeRomToFS failed', err);
          setStatus('Could not write ROM to FS; will attempt direct invocation with bytes.');
          romPath = null;
        }

        // Try to start via context/run functions with preference for GbaContext.play(...)
        await callMgbaRunFunction(romPath || data.filename, uint8);

        // send back a status message to parent
        parent.postMessage({ type: 'status', text: 'ROM loaded into iframe: ' + data.filename }, '*');
      } catch (e) {
        console.error('Failed to process ROM message', e);
        setStatus('Failed to process ROM message: ' + e.message);
        parent.postMessage({ type: 'error', text: e.message }, '*');
      }
    });

    // Local file fallback — lets user test from inside iframe as well.
    localFile.addEventListener('change', (e) => {
      const f = e.target.files && e.target.files[0];
      if (!f) return;
      const reader = new FileReader();
      reader.onload = function(evt) {
        const arr = new Uint8Array(evt.target.result);
        try {
          const path = writeRomToFS(f.name, arr);
          setStatus('Wrote ROM to FS at ' + path + '. Adapt this page to auto-run if desired.');
        } catch (err) {
          setStatus('Could not write ROM to FS: ' + (err.message || err));
        }
      };
      reader.readAsArrayBuffer(f);
    });

    // Inform parent we are ready
    parent.postMessage({ type: 'status', text: 'mGBA iframe ready' }, '*');
  </script>
</body>
</html>
